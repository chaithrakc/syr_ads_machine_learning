<?xml version='1.0' encoding='utf-8'?>
<scheme version="2.0" title="" description="">
	<nodes>
		<node id="0" name="CSV File Import" qualified_name="Orange.widgets.data.owcsvimport.OWCSVFileImport" project_name="Orange3" version="" title="CSV File Import" position="(69.0, 25.0)" />
		<node id="1" name="Data Table" qualified_name="Orange.widgets.data.owtable.OWDataTable" project_name="Orange3" version="" title="Data Table" position="(191.0, 6.0)" />
		<node id="2" name="Edit Domain" qualified_name="Orange.widgets.data.oweditdomain.OWEditDomain" project_name="Orange3" version="" title="Edit Domain" position="(357.0, -20.0)" />
		<node id="3" name="Data Sampler" qualified_name="Orange.widgets.data.owdatasampler.OWDataSampler" project_name="Orange3" version="" title="Data Sampler" position="(467.0, -39.0)" />
		<node id="4" name="Python Script" qualified_name="Orange.widgets.data.owpythonscript.OWPythonScript" project_name="Orange3" version="" title="Python Script" position="(587.0, 23.0)" />
		<node id="5" name="Data Sampler" qualified_name="Orange.widgets.data.owdatasampler.OWDataSampler" project_name="Orange3" version="" title="Data Sampler (1)" position="(420.0, 105.0)" />
		<node id="6" name="Python Script" qualified_name="Orange.widgets.data.owpythonscript.OWPythonScript" project_name="Orange3" version="" title="Python Script (1)" position="(529.0, 129.0)" />
	</nodes>
	<links>
		<link id="0" source_node_id="0" sink_node_id="1" source_channel="Data" sink_channel="Data" enabled="true" />
		<link id="1" source_node_id="1" sink_node_id="2" source_channel="Selected Data" sink_channel="Data" enabled="true" />
		<link id="2" source_node_id="2" sink_node_id="3" source_channel="Data" sink_channel="Data" enabled="true" />
		<link id="3" source_node_id="3" sink_node_id="4" source_channel="Data Sample" sink_channel="Data" enabled="true" />
		<link id="4" source_node_id="2" sink_node_id="5" source_channel="Data" sink_channel="Data" enabled="true" />
		<link id="5" source_node_id="5" sink_node_id="6" source_channel="Data Sample" sink_channel="Data" enabled="true" />
	</links>
	<annotations />
	<thumbnail />
	<node_properties>
		<properties node_id="0" format="literal">{'_session_items': [], '_session_items_v2': [({'type': 'AbsPath', 'path': 'C:/Users/Chaithra/OneDrive/Desktop/titanic-train.csv'}, {'encoding': 'utf-8', 'delimiter': ',', 'quotechar': '"', 'doublequote': True, 'skipinitialspace': True, 'quoting': 0, 'columntypes': [{'start': 0, 'stop': 11, 'value': 'Auto'}], 'rowspec': [{'start': 0, 'stop': 1, 'value': 'Header'}], 'decimal_separator': '.', 'group_separator': ''})], 'compatibility_mode': False, 'controlAreaVisible': True, 'dialog_state': {'directory': 'C:/Users/Chaithra/OneDrive/Desktop', 'filter': 'Text - comma separated (*.csv, *)'}, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x02\x84\x00\x00\x00G\x00\x00\x03\x9b\x00\x00\x01}\x00\x00\x02\x85\x00\x00\x00^\x00\x00\x03\x9a\x00\x00\x01|\x00\x00\x00\x00\x00\x00\x00\x00\x03\xc0\x00\x00\x02\x85\x00\x00\x00^\x00\x00\x03\x9a\x00\x00\x01|', '__version__': 3}</properties>
		<properties node_id="1" format="literal">{'auto_commit': True, 'color_by_class': True, 'controlAreaVisible': True, 'dist_color_RGB': (220, 220, 220, 255), 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\xff\xff\xff\xff\xff\xff\xff\xfa\x00\x00\x03\xc0\x00\x00\x01\xfe\x00\x00\x00\xa0\x00\x00\x00K\x00\x00\x03\x1f\x00\x00\x01\xb2\x00\x00\x00\x00\x02\x00\x00\x00\x03\xc0\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x03\xbf\x00\x00\x01\xfd', 'select_rows': True, 'selected_cols': [], 'selected_rows': [], 'show_attribute_labels': True, 'show_distributions': False, '__version__': 2}</properties>
		<properties node_id="2" format="pickle">gASVUwIAAAAAAAB9lCiMEmNvbnRyb2xBcmVhVmlzaWJsZZSIjBNzYXZlZFdpZGdldEdlb21ldHJ5
lENCAdnQywADAAAAAADnAAAAEwAAA2gAAAGSAAAA6AAAACoAAANnAAABkQAAAAAAAAAAA8AAAADo
AAAAKgAAA2cAAAGRlIwLX192ZXJzaW9uX1+USwKMEGNvbnRleHRfc2V0dGluZ3OUXZSMFW9yYW5n
ZXdpZGdldC5zZXR0aW5nc5SMB0NvbnRleHSUk5QpgZR9lCiMBnZhbHVlc5R9lCiMFF9kb21haW5f
Y2hhbmdlX3N0b3JllH2UKIwEUmVhbJQojAtQYXNzZW5nZXJJZJRLAIwBZpSGlCmJdJSGlF2UjA1B
c0NhdGVnb3JpY2FslCmGlGFoECiMBlBjbGFzc5RLAGgShpQpiXSUhpRdlGgXKYaUYXVK/v///4aU
jBZfbWVyZ2VfZGlhbG9nX3NldHRpbmdzlH2USvz///+GlIwOX3NlbGVjdGVkX2l0ZW2UjAtQYXNz
ZW5nZXJJZJRLAoaUSv7///+GlIwRb3V0cHV0X3RhYmxlX25hbWWUjACUSv7///+GlGgESwJ1jAph
dHRyaWJ1dGVzlH2UKIwLUGFzc2VuZ2VySWSUSwKMCFN1cnZpdmVklEsBjAZQY2xhc3OUSwKMA1Nl
eJRLAYwDQWdllEsCjAVTaWJTcJRLAowFUGFyY2iUSwKMBEZhcmWUSwKMCEVtYmFya2VklEsBdYwF
bWV0YXOUfZQojAZUaWNrZXSUSwOMBUNhYmlulEsDdXViYXUu
</properties>
		<properties node_id="3" format="literal">{'compatibility_mode': False, 'controlAreaVisible': True, 'number_of_folds': 10, 'replacement': False, 'sampleSizeNumber': 100, 'sampleSizePercentage': 70, 'sampleSizeSqlPercentage': 0.1, 'sampleSizeSqlTime': 1, 'sampling_type': 0, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a\x00\x00\x00\x00\x00\x00\x00\x00\x03\xc0\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a', 'selectedFold': 1, 'sql_dl': False, 'stratify': False, 'use_seed': False, '__version__': 2}</properties>
		<properties node_id="4" format="literal">{'controlAreaVisible': True, 'currentScriptIndex': 2, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\xff\xff\xff\xff\xff\xff\xff\xfa\x00\x00\x03\xc0\x00\x00\x01\xfe\x00\x00\x00\x00\x00\x00\x00\x14\x00\x00\x03\xbf\x00\x00\x02\x00\x00\x00\x00\x00\x02\x00\x00\x00\x03\xc0\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x03\xbf\x00\x00\x01\xfd', 'scriptLibrary': [{'name': 'Table from numpy', 'script': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\n\ndomain = Domain([ContinuousVariable("age"),\n                 ContinuousVariable("height"),\n                 DiscreteVariable("gender", values=("M", "F"))])\narr = np.array([\n  [25, 186, 0],\n  [30, 164, 1]])\nout_data = Table.from_numpy(domain, arr)\n', 'filename': None}, {'name': 'z-score-xform.py', 'script': "import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\ndf = table_to_frame(in_data)\ndf['Age Z-score'] = (df.Age - df.Age.mean()) / df.Age.std()\nout_data = table_from_frame(df)\n", 'filename': 'C:/Users/Chaithra/Downloads/z-score-xform.py'}, {'name': 'crosstab_heatmap.py', 'script': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\n\n# The following was copied from https://matplotlib.org/stable/gallery/images_contours_and_fields/image_annotated_heatmap.html\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw={}, cbarlabel="", **kwargs):\n    """\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (N, M).\n    row_labels\n        A list or array of length N with the labels for the rows.\n    col_labels\n        A list or array of length M with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    """\n\n    if not ax:\n        ax = plt.gca()\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")\n\n    # We want to show all ticks...\n    ax.set_xticks(np.arange(data.shape[1]))\n    ax.set_yticks(np.arange(data.shape[0]))\n    # ... and label them with the respective list entries.\n    ax.set_xticklabels(col_labels)\n    ax.set_yticklabels(row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha="right",\n             rotation_mode="anchor")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which="minor", color="w", linestyle=\'-\', linewidth=3)\n    ax.tick_params(which="minor", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt="{x:.2f}",\n                     textcolors=("black", "white"),\n                     threshold=None, **textkw):\n    """\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image\'s data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. "$ {x:.2f}", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    """\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment="center",\n              verticalalignment="center")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each "pixel".\n    # Change the text\'s color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) &gt; threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n\n# This line converts an Orange3 table into a Pandas DataFrame\ndf = table_to_frame(in_data)\n\nct = pd.crosstab(df.Sex,df.Survived)\nprint(ct)\nprint(ct.columns.values)\nprint(ct.index.values)\nprint(ct.to_numpy())\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(ct.to_numpy(), ct.index.values, ct.columns.values, ax=ax, cmap="YlGn", label="count")\ntexts = annotate_heatmap(im, valfmt="{x:.1f}")\n\nfig.tight_layout()\nplt.show()', 'filename': 'C:/Users/Chaithra/Downloads/crosstab_heatmap.py'}], 'scriptText': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\n\n# The following was copied from https://matplotlib.org/stable/gallery/images_contours_and_fields/image_annotated_heatmap.html\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw={}, cbarlabel="", **kwargs):\n    """\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (N, M).\n    row_labels\n        A list or array of length N with the labels for the rows.\n    col_labels\n        A list or array of length M with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    """\n\n    if not ax:\n        ax = plt.gca()\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")\n\n    # We want to show all ticks...\n    ax.set_xticks(np.arange(data.shape[1]))\n    ax.set_yticks(np.arange(data.shape[0]))\n    # ... and label them with the respective list entries.\n    ax.set_xticklabels(col_labels)\n    ax.set_yticklabels(row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha="right",\n             rotation_mode="anchor")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which="minor", color="w", linestyle=\'-\', linewidth=3)\n    ax.tick_params(which="minor", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt="{x:.2f}",\n                     textcolors=("black", "white"),\n                     threshold=None, **textkw):\n    """\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image\'s data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. "$ {x:.2f}", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    """\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment="center",\n              verticalalignment="center")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each "pixel".\n    # Change the text\'s color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) &gt; threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n\n# This line converts an Orange3 table into a Pandas DataFrame\ndf = table_to_frame(in_data)\n\nct = pd.crosstab(df.Sex,df.Survived)\nprint(ct)\nprint(ct.columns.values)\nprint(ct.index.values)\nprint(ct.to_numpy())\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(ct.to_numpy(), ct.index.values, ct.columns.values, ax=ax, cmap="YlGn", label="count")\ntexts = annotate_heatmap(im, valfmt="{x:.1f}")\n\nfig.tight_layout()\nplt.show()', 'splitterState': b'\x00\x00\x00\xff\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00|\x00\x00\x00J\x01\xff\xff\xff\xff\x01\x00\x00\x00\x02\x00', 'vimModeEnabled': False, '__version__': 2}</properties>
		<properties node_id="5" format="literal">{'compatibility_mode': False, 'controlAreaVisible': True, 'number_of_folds': 10, 'replacement': False, 'sampleSizeNumber': 100, 'sampleSizePercentage': 70, 'sampleSizeSqlPercentage': 0.1, 'sampleSizeSqlTime': 1, 'sampling_type': 0, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a\x00\x00\x00\x00\x00\x00\x00\x00\x03\xc0\x00\x00\x01\x88\x00\x00\x00d\x00\x00\x027\x00\x00\x01\x9a', 'selectedFold': 1, 'sql_dl': False, 'stratify': True, 'use_seed': True, '__version__': 2}</properties>
		<properties node_id="6" format="literal">{'controlAreaVisible': True, 'currentScriptIndex': 2, 'savedWidgetGeometry': b'\x01\xd9\xd0\xcb\x00\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x03\xbf\x00\x00\x01\xfd\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x03\xbf\x00\x00\x01\xfd\x00\x00\x00\x00\x02\x00\x00\x00\x03\xc0\x00\x00\x00\x00\x00\x00\x00\x11\x00\x00\x03\xbf\x00\x00\x01\xfd', 'scriptLibrary': [{'name': 'Table from numpy', 'script': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\n\ndomain = Domain([ContinuousVariable("age"),\n                 ContinuousVariable("height"),\n                 DiscreteVariable("gender", values=("M", "F"))])\narr = np.array([\n  [25, 186, 0],\n  [30, 164, 1]])\nout_data = Table.from_numpy(domain, arr)\n', 'filename': None}, {'name': 'z-score-xform.py', 'script': "import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\ndf = table_to_frame(in_data)\ndf['Age Z-score'] = (df.Age - df.Age.mean()) / df.Age.std()\nout_data = table_from_frame(df)\n", 'filename': 'C:/Users/Chaithra/Downloads/z-score-xform.py'}, {'name': 'crosstab_heatmap.py', 'script': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\n\n# The following was copied from https://matplotlib.org/stable/gallery/images_contours_and_fields/image_annotated_heatmap.html\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw={}, cbarlabel="", **kwargs):\n    """\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (N, M).\n    row_labels\n        A list or array of length N with the labels for the rows.\n    col_labels\n        A list or array of length M with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    """\n\n    if not ax:\n        ax = plt.gca()\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")\n\n    # We want to show all ticks...\n    ax.set_xticks(np.arange(data.shape[1]))\n    ax.set_yticks(np.arange(data.shape[0]))\n    # ... and label them with the respective list entries.\n    ax.set_xticklabels(col_labels)\n    ax.set_yticklabels(row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha="right",\n             rotation_mode="anchor")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which="minor", color="w", linestyle=\'-\', linewidth=3)\n    ax.tick_params(which="minor", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt="{x:.2f}",\n                     textcolors=("black", "white"),\n                     threshold=None, **textkw):\n    """\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image\'s data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. "$ {x:.2f}", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    """\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment="center",\n              verticalalignment="center")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each "pixel".\n    # Change the text\'s color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) &gt; threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n\n# This line converts an Orange3 table into a Pandas DataFrame\ndf = table_to_frame(in_data)\n\nct = pd.crosstab(df.Sex,df.Survived)\nprint(ct)\nprint(ct.columns.values)\nprint(ct.index.values)\nprint(ct.to_numpy())\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(ct.to_numpy(), ct.index.values, ct.columns.values, ax=ax, cmap="YlGn", label="count")\ntexts = annotate_heatmap(im, valfmt="{x:.1f}")\n\nfig.tight_layout()\nplt.show()', 'filename': 'C:/Users/Chaithra/Downloads/crosstab_heatmap.py'}], 'scriptText': 'import numpy as np\nfrom Orange.data import Table, Domain, ContinuousVariable, DiscreteVariable\nfrom Orange.data.pandas_compat import table_to_frame, table_from_frame\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib\n\n\n# The following was copied from https://matplotlib.org/stable/gallery/images_contours_and_fields/image_annotated_heatmap.html\n\ndef heatmap(data, row_labels, col_labels, ax=None,\n            cbar_kw={}, cbarlabel="", **kwargs):\n    """\n    Create a heatmap from a numpy array and two lists of labels.\n\n    Parameters\n    ----------\n    data\n        A 2D numpy array of shape (N, M).\n    row_labels\n        A list or array of length N with the labels for the rows.\n    col_labels\n        A list or array of length M with the labels for the columns.\n    ax\n        A `matplotlib.axes.Axes` instance to which the heatmap is plotted.  If\n        not provided, use current axes or create a new one.  Optional.\n    cbar_kw\n        A dictionary with arguments to `matplotlib.Figure.colorbar`.  Optional.\n    cbarlabel\n        The label for the colorbar.  Optional.\n    **kwargs\n        All other arguments are forwarded to `imshow`.\n    """\n\n    if not ax:\n        ax = plt.gca()\n\n    # Plot the heatmap\n    im = ax.imshow(data, **kwargs)\n\n    # Create colorbar\n    cbar = ax.figure.colorbar(im, ax=ax, **cbar_kw)\n    cbar.ax.set_ylabel(cbarlabel, rotation=-90, va="bottom")\n\n    # We want to show all ticks...\n    ax.set_xticks(np.arange(data.shape[1]))\n    ax.set_yticks(np.arange(data.shape[0]))\n    # ... and label them with the respective list entries.\n    ax.set_xticklabels(col_labels)\n    ax.set_yticklabels(row_labels)\n\n    # Let the horizontal axes labeling appear on top.\n    ax.tick_params(top=True, bottom=False,\n                   labeltop=True, labelbottom=False)\n\n    # Rotate the tick labels and set their alignment.\n    plt.setp(ax.get_xticklabels(), rotation=-30, ha="right",\n             rotation_mode="anchor")\n\n    # Turn spines off and create white grid.\n    ax.spines[:].set_visible(False)\n\n    ax.set_xticks(np.arange(data.shape[1]+1)-.5, minor=True)\n    ax.set_yticks(np.arange(data.shape[0]+1)-.5, minor=True)\n    ax.grid(which="minor", color="w", linestyle=\'-\', linewidth=3)\n    ax.tick_params(which="minor", bottom=False, left=False)\n\n    return im, cbar\n\n\ndef annotate_heatmap(im, data=None, valfmt="{x:.2f}",\n                     textcolors=("black", "white"),\n                     threshold=None, **textkw):\n    """\n    A function to annotate a heatmap.\n\n    Parameters\n    ----------\n    im\n        The AxesImage to be labeled.\n    data\n        Data used to annotate.  If None, the image\'s data is used.  Optional.\n    valfmt\n        The format of the annotations inside the heatmap.  This should either\n        use the string format method, e.g. "$ {x:.2f}", or be a\n        `matplotlib.ticker.Formatter`.  Optional.\n    textcolors\n        A pair of colors.  The first is used for values below a threshold,\n        the second for those above.  Optional.\n    threshold\n        Value in data units according to which the colors from textcolors are\n        applied.  If None (the default) uses the middle of the colormap as\n        separation.  Optional.\n    **kwargs\n        All other arguments are forwarded to each call to `text` used to create\n        the text labels.\n    """\n\n    if not isinstance(data, (list, np.ndarray)):\n        data = im.get_array()\n\n    # Normalize the threshold to the images color range.\n    if threshold is not None:\n        threshold = im.norm(threshold)\n    else:\n        threshold = im.norm(data.max())/2.\n\n    # Set default alignment to center, but allow it to be\n    # overwritten by textkw.\n    kw = dict(horizontalalignment="center",\n              verticalalignment="center")\n    kw.update(textkw)\n\n    # Get the formatter in case a string is supplied\n    if isinstance(valfmt, str):\n        valfmt = matplotlib.ticker.StrMethodFormatter(valfmt)\n\n    # Loop over the data and create a `Text` for each "pixel".\n    # Change the text\'s color depending on the data.\n    texts = []\n    for i in range(data.shape[0]):\n        for j in range(data.shape[1]):\n            kw.update(color=textcolors[int(im.norm(data[i, j]) &gt; threshold)])\n            text = im.axes.text(j, i, valfmt(data[i, j], None), **kw)\n            texts.append(text)\n\n    return texts\n\n\n\n# This line converts an Orange3 table into a Pandas DataFrame\ndf = table_to_frame(in_data)\n\nct = pd.crosstab(df.Sex,df.Survived)\nprint(ct)\nprint(ct.columns.values)\nprint(ct.index.values)\nprint(ct.to_numpy())\n\nfig, ax = plt.subplots()\n\nim, cbar = heatmap(ct.to_numpy(), ct.index.values, ct.columns.values, ax=ax, cmap="YlGn", label="count")\ntexts = annotate_heatmap(im, valfmt="{x:.1f}")\n\nfig.tight_layout()\nplt.show()', 'splitterState': b'\x00\x00\x00\xff\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00|\x00\x00\x00J\x01\xff\xff\xff\xff\x01\x00\x00\x00\x02\x00', 'vimModeEnabled': False, '__version__': 2}</properties>
	</node_properties>
	<session_state>
		<window_groups />
	</session_state>
</scheme>
